<!DOCTYPE html>
<html>

<head>
    <title>Visualization of fast beacon</title>
    <style>
        #network {
            width: 100%;
            height: 1200px;
        }
    </style>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>

<body>
    <div id="network"></div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {

            var graphData = {
                nodes: new vis.DataSet([]),
                edges: new vis.DataSet([]),
            };

            // Create options for the visualization
            var options = {};

            // Create a new network instance
            var container = document.getElementById("network");
            var network = new vis.Network(container, graphData, options);

            const client = new WebSocket('wss://ris-live.ripe.net/v1/ws/?client=js-example-1');

            const params = {
                moreSpecific: true,
                prefix: '84.205.66.0/24',
                type: 'UPDATE',
                socketOptions: {
                    includeRaw: true,
                    acknowledge: true
                }
            };

            //  Maybe add options: 
            // - beacons => ipv6 or ipv4.
            // - multipath or width (createEdgeId with peer or not)

            const urlParams = new URLSearchParams(window.location.search);
            const MAX_PATH_LEN = parseInt(urlParams.get('maxPathLen')) || 3;


            const createEdgeId = function (cur, next, peer) {
                return cur + "-" + next;
            }

            const renderAnnouncementPath = function (peer, path) {

                var cur = "";

                for (x in path) {
                    if (cur == "") {
                        cur = String(path[x]);
                        continue;
                    }

                    var next = String(path[x]);
                    if (!graphData.nodes.get(cur)) {
                        var nodeColor = cur == path[0] ? "red" : "blue";
                        graphData.nodes.add({
                            id: cur,
                            label: cur,
                            color: nodeColor,
                            font: {
                                color: "#FFFFFF"
                            }
                        });
                    }

                    if (!graphData.nodes.get(next)) {
                        graphData.nodes.add({
                            id: next,
                            label: next,
                            color: "blue",
                            font: {
                                color: "#FFFFFF"
                            }
                        });
                    }

                    var edgeId = createEdgeId(cur, next, peer);

                    if (!graphData.edges.get(edgeId)) {
                        graphData.edges.add({
                            id: edgeId,
                            from: cur,
                            to: next,
                            width: 1,
                            count: 1
                        });
                        console.log("\tAdded edge: ", cur, next);
                    } else {
                        var curEdge = graphData.edges.get(edgeId);
                        var curCount = curEdge.count + 1;
                        var curWidth = curCount < 15 ? curCount : 15;
                        graphData.edges.update({
                            id: edgeId,
                            from: cur,
                            to: next,
                            width: curWidth,
                            count: curCount
                        });
                    }
                    cur = next;
                }
            }

            const removeWithdrawnPath = function (peer, path) {

                var cur = "";
                for (x in path) {
                    if (cur == "") {
                        cur = String(path[x]);
                        continue;
                    }


                    var next = String(path[x]);
                    var edgeId = createEdgeId(cur, next, peer);
                    var curEdge = graphData.edges.get(edgeId);
                    if (curEdge.count > 1) {
                        var curCount = curEdge.count - 1;
                        var curWidth = curCount >= 15 ? 15 : curCount;
                        graphData.edges.update({
                            id: edgeId,
                            from: cur,
                            to: next,
                            width: curWidth,
                            count: curCount
                        });
                        console.log("\tDecrease edge width ", cur, next, curEdge.width);
                    } else {
                        var removed = graphData.edges.remove(edgeId);
                        console.log("\tRemove edge ", cur, next, removed);
                    }
                    if (network.getConnectedEdges(cur).length == 0) {
                        graphData.nodes.remove(cur);
                    }
                    cur = next;
                }
                if (network.getConnectedEdges(cur).length == 0) {
                    graphData.nodes.remove(cur);
                }
                console.log("Withdrawn", path);

            }

            const peerAsnState = {};
            client.onopen = function () {
                client.send(JSON.stringify({
                    type: 'ris_subscribe',
                    data: params
                }));
            };

            client.onmessage = function (message) {

                const msg = JSON.parse(message.data).data;
                const curPeerAsn = msg.peer_asn;

                if (msg.announcements.length > 0) {

                    var curPath = msg.path;

                    if (curPath.length <= MAX_PATH_LEN) {

                        if (curPeerAsn in peerAsnState) {
                            removeWithdrawnPath(curPeerAsn, peerAsnState[curPeerAsn]);
                            peerAsnState[curPeerAsn] = curPath;
                            console.log('Replace path for peer: ', curPeerAsn, curPath);
                        } else {
                            peerAsnState[curPeerAsn] = curPath;
                            console.log('New Path: ', curPeerAsn, curPath);
                        }

                        renderAnnouncementPath(curPeerAsn, curPath);
                    }

                } else if (msg.withdrawals.length > 0) {

                    if (curPeerAsn in peerAsnState) {

                        var curPath = peerAsnState[curPeerAsn];
                        console.log('Withdraw paths of : ', curPeerAsn, curPath);
                        removeWithdrawnPath(curPeerAsn, curPath);

                        delete peerAsnState[curPeerAsn];
                    }
                }
            };

        });
    </script>
</body>

</html>
